from _typeshed import Incomplete

MAX_MEM_BLOCK: Incomplete

def frame(x, *, frame_length, hop_length, axis: int = ..., writeable: bool = ..., subok: bool = ...): ...
def valid_audio(y, *, mono=...): ...
def valid_int(x, *, cast: Incomplete | None = ...): ...
def is_positive_int(x): ...
def valid_intervals(intervals): ...
def pad_center(data, *, size, axis: int = ..., **kwargs): ...
def expand_to(x, *, ndim, axes): ...
def fix_length(data, *, size, axis: int = ..., **kwargs): ...
def fix_frames(frames, *, x_min: int = ..., x_max: Incomplete | None = ..., pad: bool = ...): ...
def axis_sort(S, *, axis: int = ..., index: bool = ..., value: Incomplete | None = ...): ...
def normalize(S, *, norm=..., axis: int = ..., threshold: Incomplete | None = ..., fill: Incomplete | None = ...): ...
def localmax(x, *, axis: int = ...): ...
def localmin(x, *, axis: int = ...): ...
def peak_pick(x, *, pre_max, post_max, pre_avg, post_avg, delta, wait): ...
def sparsify_rows(x, *, quantile: float = ..., dtype: Incomplete | None = ...): ...
def buf_to_float(x, *, n_bytes: int = ..., dtype=...): ...
def index_to_slice(idx, *, idx_min: Incomplete | None = ..., idx_max: Incomplete | None = ..., step: Incomplete | None = ..., pad: bool = ...): ...
def sync(data, idx, *, aggregate: Incomplete | None = ..., pad: bool = ..., axis: int = ...): ...
def softmask(X, X_ref, *, power: int = ..., split_zeros: bool = ...): ...
def tiny(x): ...
def fill_off_diagonal(x, *, radius, value: int = ...) -> None: ...
def cyclic_gradient(data, *, edge_order: int = ..., axis: int = ...): ...
def shear(X, *, factor: int = ..., axis: int = ...): ...
def stack(arrays, *, axis: int = ...): ...
def dtype_r2c(d, *, default=...): ...
def dtype_c2r(d, *, default=...): ...
def count_unique(data, *, axis: int = ...): ...
def is_unique(data, *, axis: int = ...): ...
def abs2(x): ...
def phasor(angles, *, mag: Incomplete | None = ...): ...
